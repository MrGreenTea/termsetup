actually, that’s a feature.
did you check for a virus on your system?
even though it doesn’t work, how does it feel?
everything looks fine on my end.
how is that possible?
I accidentally used a deprecated function.
I assumed it would never need to handle that much data.
I assumed someone else was handling the testing.
I assumed someone else would handle that task.
I broke that deliberately to do some testing.
I can’t make that a priority right now.
I can’t test everything.
I couldn’t find any examples of how that can be done anywhere online.
I couldn’t find any library that can even do that.
I did a quick fix last time but it broke when we rebooted.
I didn’t anticipate that I would make any errors.
I didn’t create that part of the program.
I didn’t have access to the full documentation.
I didn’t have enough test data.
I didn’t have the right permissions to test that.
I didn’t realize that configuration needed to be updated.
I didn’t realize that feature had been deployed.
I didn’t receive a ticket for it.
I didn’t think anyone would use it like that.
I don’t have access to that part of the system.
I forgot to commit the code that fixes that.
I got pulled into another project that needed to be done urgently.
I had to follow the outdated documentation.
I have never seen that before in my life.
I haven’t been able to reproduce that.
I haven’t checked the error logs yet.
I haven’t had a chance to run that code yet.
I haven’t had any experience with that before.
I haven’t had time to review the logs yet.
I haven’t touched that code in weeks.
I have too many other high priority things to do right now.
I heard there was a solar flare today.
I’ll have to ask the original developer about that.
I’ll have to fix that at a later date.
I’ll need more time to reproduce the issue.
I’m not familiar with it so I didn’t fix it in case I made it worse.
I’m not getting any error codes.
I’m not sure as I’ve never had a look at how that works before.
I’m still working on that as we speak.
I’m sure it’s a caching problem.
I’m surprised it was working at all.
I’m surprised it works as well as it does.
I must have been stress-testing our production server.
I must not have understood what you were asking for.
I’m waiting on another team to complete their part.
I ran out of time to refactor the code.
it can’t be broken, it passes all unit tests.
I think the script might have run twice.
I thought he knew the context of what I was talking about.
I thought I finished that.
I thought it was only a warning, not an error.
I thought someone else was responsible for that.
I thought that change was already deployed.
I thought you signed off on that.
it must be a hardware problem.
it must be a memory leak.
it must be an intermittent problem.
it must be an issue with the load balancer.
it must be a race condition.
it must be because of a leap year.
it must have been a temporary outage.
it must have been caused by a missing dependency.
I told you yesterday it would be done by the end of today.
it probably won’t happen again.
it’s a browser compatibility issue.
it’s a bug, but it’s not critical.
it’s a character encoding issue.
it’s a compatibility issue.
it’s a known bug with the programming language.
it’s a known issue with the third-party library.
it’s a legacy issue we can’t fix easily.
it’s always been like that.
it’s an experimental feature.
it’s an issue with our service provider.
it’s an unexpected emergent behaviour of several last minute abstractions.
it’s a problem with the mobile version of the app.
it’s a regional server issue.
it’s a remote vendor issue.
it’s just some unlucky coincidence.
it’s never done that before.
it’s never shown unexpected behavior like this before.
it’s not a bug, it’s a misunderstanding of the feature.
it’s not a code problem — our users need more training.
it’s not a critical issue, so I deprioritized it.
it’s not optimized for your hardware.
it’s probably an undocumented breaking change in the API.
it’s probably a problem with your operating system.
it’s technically working, just not the way you expect.
it’s too complicated to explain right now.
it was working in my head.
it worked fine before the last update.
it worked fine during the demo.
it worked fine in isolation.
it works, but it’s not been tested.
it works for me.
it would have taken twice as long to build it properly.
it would take too long to rewrite the code from scratch.
I usually get a notification when that happens.
I was just fixing that.
I wasn’t aware that feature was enabled.
I wasn’t aware that was a requirement.
I wasn’t informed about the latest changes.
I wasn’t the last one to touch it.
I was testing a hypothesis.
I was told to stop working on that when something important came up.
I was working on a workaround instead of a fix.
management insisted we wouldn’t need to waste our time writing unit tests.
maybe somebody forgot to pay our hosting company.
my time was split in a way that meant I couldn’t do either project properly.
nobody asked me how long it would actually take.
nobody has ever complained about it.
no one told me so I was forced to assume which way to do that.
oh, that was just a temporary fix.
oh, that was only supposed to be a placeholder.
our code quality is no worse than anyone else in the industry.
our hardware is too slow to cope with demand.
our internet connection must not be working.
our redundant systems must have failed as well.
please ignore that, it’s for debugging.
somebody must have changed my code.
someone accidentally commented out that code.
that behaviour is in the original specification.
that bug is caused by an undocumented feature.
that code seemed so simple I didn’t think it needed testing.
that error means it was successful.
that feature is experimental.
that feature was slated for phase two.
that feature would be outside the scope.
that functionality is still in beta.
that important email must have been marked as spam.
that isn’t covered by my job description.
that issue only happens under very specific conditions.
that problem is outside of our control.
that process requires human oversight that nobody was providing.
that’s a known edge case.
that’s a limitation of the hardware.
that’s already fixed, it just hasn’t taken effect yet.
that’s an external dependency issue.
that’s an unexpected interaction with another module.
that’s a problem with the library, not our code.
that’s interesting, how did you manage to make it do that?
that’s just a cosmetic issue, not a functional one.
that’s just how the framework works.
that’s not a bug it’s a configuration issue.
that’s the default behavior of the operating system.
that’s the fault of the graphic designer.
that tool isn’t compatible with the latest version.
that was literally a one in a million error.
that wasn’t in the original specification.
that worked perfectly when I developed it.
that wouldn’t be economically feasible.
the accounting department must have cancelled that subscription.
the API key must have expired.
the API must have changed without notice.
the build server must be misconfigured.
the client must have been hacked.
the client wanted it changed at the last minute.
the codebase is too old to modify easily.
the code is compiling.
the compiler must have optimized something incorrectly.
the database must have been locked when I ran that query.
the debugger skipped over that part of the code.
the design constraints didn’t account for that scenario.
the DNS hasn’t propagated yet.
the download must have been corrupted.
the error messages are not descriptive enough.
the existing design makes it difficult to do the right thing.
the feature was deprioritized due to other deadlines.
the framework we’re using has a known limitation.
the input data didn’t meet the expected format.
the latest patch must have introduced that bug.
the logs were rotated before I could analyze them.
the marketing department made us put that there.
the permissions were set incorrectly.
the person responsible doesn’t work here anymore.
the problem seems to be with our legacy software.
the program has never collected that information.
the project manager said no one would want that feature.
the project manager told me to do it that way.
there must be something strange in your data.
there must have been a typo in the deployment script.
the request must have dropped some packets.
there’s currently a problem with our hosting company.
there was a conflict in the merge.
there was too little data to bother with the extra functionality at the time.
the sandbox environment behaves differently.
the script wasn’t tested in production.
the server time must be off.
the server was overloaded at the time.
the specifications were ambiguous.
the specs didn’t mention that scenario.
the staging environment doesn’t mirror production exactly.
the system requires a reboot to apply the fix.
the test cases didn’t cover that edge case.
the test environment wasn’t configured properly.
the third party documentation doesn’t exist.
the timezone settings were incorrect.
the upgrade introduced some unforeseen issues.
the user must not know how to use it.
the version control history is unclear.
THIS can’t be the source of THAT.
this code was not supposed to go in to production yet.
this is a previously known bug you told me not to work on yet.
we didn’t budget enough time for testing.
we didn’t have enough time to peer review the final changes.
we don’t have the budget to address that.
well, at least it displays a very pretty error.
well, at least we know not to try that again.
well done, you found my easter egg!
well, that’s a first.
we need to apply the latest security patch first.
we need to consult with the vendor before making changes.
we’re waiting for feedback from the client.
what did I tell you about using parts of the system you don’t understand?
what did you type in wrong to get it to crash?
where were you when the program blew up?
why do you want to do it that way?
you DIDN’T want that to happen?
you must have done something wrong.
you must have the wrong version.
you’re doing it wrong.
you used the wrong compiling options in the build I made.
